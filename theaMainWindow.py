# -*- coding: iso-8859-1 -*-

import iris, cartopy, matplotlib, theaMainInterface, colorbarOptions, matplotlibwidgetFile
import CubeControl as cc
import guiLogic as logic
import matplotlib.pyplot as plt
import iris.plot as iplt
import numpy as np
from PySide import QtGui, QtCore
from PySide.QtGui import QApplication, QCursor
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar


class GUI(QtGui.QMainWindow, theaMainInterface.Ui_MainWindow):
  
  
  def __init__(self):

    super(GUI, self).__init__()
    self.initUI()
    self.setStateIndicators()
    self.cbDialog = colorbarOptions.ColorbarOptions()
    self.setActions()    
    
    
  def initUI(self):
    """
    This method sets up the initial layout of the GUI. 
    
    We first call setupUi, a method from theaUI, which has been generated by Qt to recreate the 
    interface created in Qt Designer.
   
    We are then able to attatch the matplotlib toolbar our embedded image.
    
    The window is then displayed 
    """
    
    self.setupUi(self)
       
    self.mpl_toolbar = NavigationToolbar(self.matplotlibDisplay.canvas, self.matplotlibDisplay)
    self.matplotlibDisplay.vbl.addWidget(self.mpl_toolbar)
        
    self.show()    
 
  def setActions(self):
    """
    This function sets up all of the interactivity for the GUI (except for that which was implemented 
    directly in Qt Designer)
    
    activated / triggered => when the user interacts with the object (ie. will not be sent if a method in this code
		 changes the object)
		 
    currentValueChanged and similar => when the object is changed by anything
    
    """
    
    self.updateButton.clicked.connect(self.update)
    
    self.actionOpen.triggered.connect(self.showOpenDialog)
    self.actionSave.triggered.connect(self.showSaveDialog)
    self.actionColorbar.triggered.connect(self.showColorbarDialog)
    self.actionGridlines.triggered.connect(self.stateChanged)
    self.actionCoastlines.triggered.connect(self.stateChanged)
    self.actionCountry_Boundaries.triggered.connect(self.stateChanged)
    self.actionRivers_and_Lakes.triggered.connect(self.stateChanged)
    self.actionFix_Colorbar.triggered.connect(self.stateChangedFix)
    self.actionContour_Labels.triggered.connect(self.stateChanged)
    self.actionNextSlice.triggered.connect(self.nextSlice)
    self.actionPreviousSlice.triggered.connect(self.previousSlice)
    
    self.selectPlotType.activated.connect(self.stateChangedPlotType)
    self.selectProjection.currentIndexChanged.connect(self.stateChanged)
    self.selectColormap.currentIndexChanged.connect(self.stateChanged)
    self.contourSlider.valueChanged.connect(self.stateChanged)
    
    self.selectCube.activated.connect(self.setDimensionCombos)
    self.selectCube.activated.connect(self.stateChangedSlicedDim)
    self.selectDimension1.activated.connect(self.stateChangedAxis)
    self.selectDimension2.activated.connect(self.stateChangedAxis)
    self.selectSlicedDim.currentIndexChanged.connect(self.stateChangedSlicedDim)
    self.selectSliceCombo.currentIndexChanged.connect(self.stateChanged)
    for i in range(6):
      exec("self.selectSliceIndex{}.currentIndexChanged.connect(self.stateChanged)".format(i+1))
    
    self.selectDimension1.activated.connect(self.arrangeCoords1)
    self.selectDimension2.activated.connect(self.arrangeCoords2)
    self.selectSlicedDim.activated.connect(self.arrangeCoords3)
    
    self.cbDialog.autoselectRange.stateChanged.connect(self.stateChanged)
    self.cbDialog.minContour.valueChanged.connect(self.stateChanged)
    self.cbDialog.maxContour.valueChanged.connect(self.stateChanged)
    
    self.cubeInfoTab.currentChanged.connect(self.showData)


  def setDimensionCombos(self):
    
    QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
    self.statusBar().showMessage('Updating Interface')
    self.clearDims()

    dim_names = [dim_coord.name() for dim_coord in self.cube.dim_coords]
    missing_dims = cc.getMissingCoords(self.cube)

    enabled, data = logic.getDataSelectDim1(dim_names, missing_dims)
    self.fillCombo("selectDimension1", enabled, data)
    
    enabled, data = logic.getDataSelectDim2(dim_names, missing_dims)
    self.fillCombo("selectDimension2", enabled, data)
    
    if self.cube.ndim > 2:
      
      enabled, data = logic.getDataSelectSlicedDim(self.cube, dim_names)
      self.fillCombo("selectSlicedDim", enabled, data)
      
      enabled, data = logic.getDataSelectSliceIndex(self.cube, self.selectSlicedDim.currentText())
      self.fillCombo("selectSliceCombo", enabled, data)
      self.setSliceScroll()
      self.selectSliceScroll.setEnabled(True)
      self.selectSliceScroll.setRange
      self.actionNextSlice.setEnabled(True)
      self.actionPreviousSlice.setEnabled(True)
      self.actionLoadSlices.setEnabled(True)
    
    self.setInitialIndex(missing_dims)
    
    self.setCollapsedDims()
    self.stateChangedAxis()
      
    self.dim1 = self.selectDimension1.currentIndex()
    self.dim2 = self.selectDimension2.currentIndex()
    self.dim3 = self.selectSlicedDim.currentIndex()        
    QApplication.restoreOverrideCursor()


    
  def update(self):
    
    QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
    
    self.updateButton.setEnabled(False)
    
    cube = self.getCurrentCube()
    plotType = self.selectPlotType.currentText()
    projection = self.selectProjection.currentText()
    cmap = self.selectColormap.currentText()
    Ncontours = self.contourSlider.value()
    coastlines = self.actionCoastlines.isChecked()
    gridlines = self.actionGridlines.isChecked()
    contourLabels = self.actionContour_Labels.isChecked()
    countries = self.actionCountry_Boundaries.isChecked()
    rivers = self.actionRivers_and_Lakes.isChecked()
    dim1_name = self.selectDimension1.currentText()
    dim1_index = self.selectDimension1.currentIndex()
    dim2_name = self.selectDimension2.currentText()
    dim2_index = self.selectDimension2.currentIndex()
    slicedDimName = self.selectSlicedDim.currentText()
    slicedDimIndex = self.selectSlicedDim.currentIndex()
    sliceIndex = self.selectSliceScroll.value()
    collapsedNames = []
    collapsedIndices = []
    for i in range(cube.ndim - 3):
      exec("collapsedNames.append(self.collapsedDim{}.text())".format(i+1))
      exec("collapsedIndices.append(self.selectSliceIndex{}.currentIndex())".format(i+1))
    if self.cbDialog.autoselectRange.isChecked():
      cbMax = None
      cbMin = None
    elif self.cbDialog.fixedColorbar.isChecked():
      if self.fixedCb == False:
	self.Max, self.Min = cc.setFixedColorbar(cube, dim1_name, dim2_name, slicedDimName, dim1_index, dim2_index, slicedDimIndex, collapsedIndices)
	self.fixedCb == True
      cbMax = self.Max
      cbMin = self.Min
    else:
      cbMax = self.cbDialog.maxContour.value()
      cbMin = self.cbDialog.minContour.value()
    
    self.clearFig()
    
    self.statusBar().showMessage('Plotting Cube')
    try:
      self.plotted_cube = cc.update(cube, plotType, projection, cmap, Ncontours, coastlines, gridlines, contourLabels, countries, rivers,
		cbMax, cbMin, dim1_name, dim1_index, dim2_name, dim2_index, slicedDimName,
		slicedDimIndex, sliceIndex, collapsedNames, collapsedIndices)
    
    except Exception as e:
      flags = QtGui.QMessageBox.StandardButton.Ok
      response = QtGui.QMessageBox.critical(self, 'Unable to plot cube!', str(e), flags)
      self.statusBar().showMessage('Failed to Plot Cube')
      QApplication.restoreOverrideCursor()
    
    self.statusBar().showMessage('Drawing Plot')
    self.display()
    self.printCubeSliceBrowser.setText(str(self.plotted_cube))
    self.statusBar().showMessage('Ready')
    QApplication.restoreOverrideCursor()



  def showOpenDialog(self):
    """
    Handles the loading of a file, and calls functions to set up the GUI accordingly and then display the cube
    """
    
    self.filename, _ = QtGui.QFileDialog.getOpenFileName(self, 'Open File', '/project/avd/iris/resources/public_sample_data_1.0')
    self.clearAll()
    
    QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
    self.statusBar().showMessage('Loading Cube')
    try:
      self.cubes = iris.load(self.filename)
    except ValueError as e:
      flags = QtGui.QMessageBox.StandardButton.Ok
      response = QtGui.QMessageBox.critical(self, 'Unable to Load Cube: File type could not be read', str(e), flags) 
      self.statusBar().showMessage('Load Failed')
      QApplication.restoreOverrideCursor()
    QApplication.restoreOverrideCursor()
    
    for self.cube in self.cubes:
      self.selectCube.addItem(self.cube.name())        #fills the selectCube combo box with the cubes from the file
    if len(self.cubes) == 1:
      self.selectCube.setEnabled(False)
    else:
      self.selectCube.setEnabled(True)
    self.cubeLoaded = True
    
    self.printCubeBrowser.setText(str(self.cube))

    self.setDimensionCombos()
    self.update()
    
  
  def showSaveDialog(self):
    """
    Saves the image which is currently being displayed
    """
    
    filename,_ = QtGui.QFileDialog.getSaveFileName()
    
    QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
    self.statusBar().showMessage('Saving')
    
    try:
      plt.savefig(filename)
    except Exception as e:
      flags = QtGui.QMessageBox.StandardButton.Ok
      response = QtGui.QMessageBox.critical(self, 'Unable to Save Cube', str(e), flags) 
      self.statusBar().showMessage('Save Failed')
    
    QApplication.restoreOverrideCursor()
    self.statusBar().showMessage('Ready')
    
    
    
  def setStateIndicators(self):
    
    self.tableDrawn = False    #A variable to help reduce the number of times that the table is drawn
    self.cubeLoaded = False    #A variable used to ensure that the program does not crash attempting to draw cubes before one is loaded.
    self.updateButton.setEnabled(False)
    self.fixedCb = "No"
    
    
  def getCurrentCube(self):
    
    cube_index = self.selectCube.currentIndex()
    return self.cubes[cube_index]
    
  
  def fillCombo (self, comboBox, enabled, items):
    
    if enabled:
      exec("self.{}.setEnabled(True)".format(comboBox))
      exec("self.{}.clear()".format(comboBox))
      for item in items:
	exec("self.{}.addItem(str(item))".format(comboBox))
    else:
      exec("self.{}.setEnabled(False)".format(comboBox))

    
    
  def showColorbarDialog(self):
    
    self.cbDialog.show()    


  def stateChanged(self):
    """
    when an option has been changed, we re-enable
    the update button.
    """
    self.updateButton.setEnabled(True)
    

  def stateChangedFix(self):
    """
    Marks that the fix contour button has been pressed
    """
    self.updateButton.setEnabled(True)
    if self.fixedCb == "No":
      self.fixedCb = "clicked"
    else:
      self.fixedCb = "No"
    
    
  def stateChangedSlicedDim(self):
    """
    any change in which the sliced dimension might have 
    changed.
    """
    
    self.stateChanged()  
    self.stateChangedAxis()
    self.fixedCb = False
    if self.cube.ndim >= 3:
      self.actionLoadSlices.setEnabled(True)
      self.actionLoadSlices.setChecked(False)
      
  def stateChangedAxis(self):
    """
    every time the 2 plotted dimensions change, we check
    to see if it makes sense to pick projections or geographic
    feature. If it does, then these buttons are enabled, if not,
    then they are disabled. 
    """
    valid_dims = False
    self.stateChanged()
    
    if cc.getMissingCoords(self.cube) == 0 :
      if self.cube.ndim > 1:
	coord1 = self.selectDimension1.currentText()
	coord2 = self.selectDimension2.currentText()
    
	exec ("valid_dims = iplt._can_draw_map([self.cube.coord('{}'),self.cube.coord('{}')])".format(coord1, coord2))
	  
    if valid_dims == True:
      self.selectProjection.setEnabled(True)
      self.actionCoastlines.setEnabled(True)
      self.actionRivers_and_Lakes.setEnabled(True)
      self.actionCountry_Boundaries.setEnabled(True)
    else:
      self.selectProjection.setCurrentIndex(0)
      self.selectProjection.setEnabled(False)
      self.actionCoastlines.setEnabled(False)
      self.actionRivers_and_Lakes.setEnabled(False)
      self.actionCountry_Boundaries.setEnabled(False)
      
      
      
  def stateChangedPlotType(self):
    """
    controls buttons that only make sense for some types of plot.
    """
    self.stateChanged()
    
    if self.selectPlotType.currentText() == "pcolormesh":
      self.contourSlider.setEnabled(False)
      self.actionContour_Labels.setEnabled(False)
    elif self.selectPlotType.currentText() == "Contour":
      self.actionContour_Labels.setEnabled(True)
    else:
      self.contourSlider.setEnabled(True)
      self.actionContour_Labels.setEnabled(False)
      
      
  def setInitialIndex(self, missing_dims):
    
    if missing_dims == 0:
      self.selectDimension1.setCurrentIndex(self.cube.ndim - 2)
      self.selectDimension2.setCurrentIndex(self.cube.ndim - 1)
      if self.cube.ndim > 2:
	self.selectSlicedDim.setCurrentIndex(0)
      
   
  def clearAll(self):
    
    self.clearDims()
    self.clearFig()
    self.selectCube.clear()
    self.actionNextSlice.setEnabled(False)
    self.actionPreviousSlice.setEnabled(False)
   
  def clearDims(self):
    
    self.selectDimension1.clear()
    self.selectDimension2.clear()
    self.selectSlicedDim.clear()
    
    self.selectDimension1.setEnabled(False)
    self.selectDimension2.setEnabled(False)
    self.selectSlicedDim.setEnabled(False)
    self.selectSliceCombo.setEnabled(False)
    self.selectSliceScroll.setEnabled(False)
    self.actionLoadSlices.setEnabled(False)
    
    for i in range(6):
      exec("self.collapsedDim{}.clear()".format(i+1))
      exec("self.selectSliceIndex{}.clear()".format(i+1))
      exec("self.selectSliceIndex{}.setEnabled(False)".format(i+1))
      
  
  def clearFig(self):

    im = plt.clf()
    self.display()
      
      
  def nextSlice(self):
    
    i = self.selectSliceCombo.currentIndex()
    self.selectSliceCombo.setCurrentIndex(i+1)
    self.update()
    
  def previousSlice(self):
    
    i = self.selectSliceCombo.currentIndex()
    if i == 0:
      i = self.selectSliceCombo.count()
    self.selectSliceCombo.setCurrentIndex(i-1)
    self.update()



  def arrangeCoords1(self): 
  
    """
    The arrange Methods are present to prevent any one coordinate being used more than once in the 
    selectDimension1, selectDimension2 and selectSlicedDim combo boxes. 
    
    When a coordinate is selected in any one of the combo boxes, it checks the other 2 for matches 
    and if matches are found then it will put the old value for the selected combo box into the 
    combo box with the match. 
    """
    
    if self.selectDimension1.currentText() == self.selectDimension2.currentText():
      self.selectDimension2.setCurrentIndex(self.dim1)
    elif self.selectDimension1.currentText() == self.selectSlicedDim.currentText():
      self.selectSlicedDim.setCurrentIndex(self.dim1)
	
    self.dim1 = self.selectDimension1.currentIndex()
    self.dim2 = self.selectDimension2.currentIndex()
    self.dim3 = self.selectSlicedDim.currentIndex()
 
    enabled, data = logic.getDataSelectSliceIndex(self.cube, self.selectSlicedDim.currentText())
    self.fillCombo("selectSliceCombo", enabled, data)
    self.setSliceScroll()
    
    self.setCollapsedDims()
    
    
  def arrangeCoords2(self): 
    
    if self.selectDimension2.currentText() == self.selectDimension1.currentText():
      self.selectDimension1.setCurrentIndex(self.dim2)
    elif self.selectDimension2.currentText() == self.selectSlicedDim.currentText():
      self.selectSlicedDim.setCurrentIndex(self.dim2)
	
    self.dim1 = self.selectDimension1.currentIndex()
    self.dim2 = self.selectDimension2.currentIndex()
    self.dim3 = self.selectSlicedDim.currentIndex()
	
    enabled, data = logic.getDataSelectSliceIndex(self.cube, self.selectSlicedDim.currentText())
    self.fillCombo("selectSliceCombo", enabled, data)
    self.setSliceScroll()
    
    self.setCollapsedDims()


  def arrangeCoords3(self):  
    
    if self.selectSlicedDim.currentText() == self.selectDimension1.currentText():
      self.selectDimension1.setCurrentIndex(self.dim3)
    elif self.selectSlicedDim.currentText() == self.selectDimension2.currentText():
      self.selectDimension2.setCurrentIndex(self.dim3)
	
    self.dim1 = self.selectDimension1.currentIndex()
    self.dim2 = self.selectDimension2.currentIndex()
    self.dim3 = self.selectSlicedDim.currentIndex()
    
    enabled, data = logic.getDataSelectSliceIndex(self.cube, self.selectSlicedDim.currentText())
    self.fillCombo("selectSliceCombo", enabled, data)
    self.setSliceScroll()
    
    self.setCollapsedDims()
    
    
  def setCollapsedDims(self):
    
    """
    Beyond 3 dimensions, the program allows you to pick a single value to collapse the cube
    around. This method fills and enables the relevant labels and combo boxes to allow this.
    """
    
    if self.cube.ndim > 3:
      usedDims = []
      usedDims.append(self.selectDimension1.currentText())
      usedDims.append(self.selectDimension2.currentText())
      usedDims.append(self.selectSlicedDim.currentText())
      dim_names = [dim_coord.name() for dim_coord in self.cube.dim_coords]
      
      unusedDims = logic.getRemainingDims(dim_names, usedDims)
	    
      i = 1
      for dimension in unusedDims:
	exec("self.collapsedDim{}.setText(dimension)".format(i))
	enabled, data = logic.getDataSelectSliceIndex(self.cube, dimension)
	exec("self.fillCombo('selectSliceIndex{}', enabled, data)".format(i))
	i += 1

  
  
  def setSliceScroll(self): #Sets the maximum value of the scroll bar
  
    sliced_coord = self.selectSlicedDim.currentText()
    max_slice = len(self.cube.coord(sliced_coord).points)
    self.selectSliceScroll.setMaximum(max_slice - 1)
     
     
     
  def showData(self):
    
    """
    Here we take the currently plotted cube (in general NOT the full cube)
    and write the data in it into a table. 
    
    The table used is a table widget from Qt. This has the advantage of an
    elegant presentation and could in future support interactivity with the 
    plot, as clicking on a cell can be used as a signal. 
    However, the disadvantage of this method is that it is quite slow. This 
    is probably because of the number of objects created to draw the table,
    and because each of the objects is more complicated than required as they
    are capable of holding more complex objects such as buttons.
    This lack of speed may require a rewrite of this section.
    """
    
    if self.tableDrawn == False and self.cubeInfoTab.currentIndex() == 2:
      
      QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
      self.statusBar().showMessage('Constructing Data Table')
      self.dataViewer.clear()
      
      coord1 = self.selectDimension1.currentText()
      coord2 = self.selectDimension2.currentText()
      shape = self.plotted_cube.shape
      self.dataViewer.setColumnCount(shape[1])
      self.dataViewer.setRowCount(shape[0])
      headersx = []
      headersy = []

      for i in range(shape[0]):
	headersx.append(str(self.cube.coord(coord1).points[i])) 
      self.dataViewer.setVerticalHeaderLabels(headersx)
      for j in range(shape[1]):
	headersy.append(str(self.cube.coord(coord2).points[j])) 
      self.dataViewer.setHorizontalHeaderLabels(headersy)
	
      for i in range(shape[0]):
	for j in range(shape[1]):
	  exec("lbl{}{} = QtGui.QLabel()".format(i,j))
	  exec("lbl{}{}.setText(str(self.plotted_cube.data[i,j]))".format(i,j))
	  exec("self.dataViewer.setCellWidget(i,j,lbl{}{})".format(i,j))
	  
      QApplication.restoreOverrideCursor()  
      self.statusBar().showMessage('Ready')
      self.tableDrawn = True
      
      
  def display(self):
    
    matplotlibwidgetFile.fig = plt.gcf()
    self.matplotlibDisplay.canvas.draw()
    